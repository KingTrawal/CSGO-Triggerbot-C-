using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace Triggerbot
{
    class Program
    {
        static void Main(string[] args)
        {
            IntPtr hwnd = Process.GetProcessesByName("csgo")[0].MainWindowHandle;
            uint client = GetModuleBaseAddress("client.dll", hwnd);
            uint localPlayer = ReadMemory<uint>(client + 0xA0F4F4);

            while (true)
            {
                int crosshairId = ReadMemory<int>(localPlayer + 0xB2A4);
                int team = ReadMemory<int>(localPlayer + 0xF0);

                if (crosshairId > 0 && crosshairId <= 64 && team != ReadMemory<int>(ReadMemory<uint>(client + 0xA0A6A4) + (crosshairId - 1) * 0x10 + 0xF0))
                {
                    WriteMemory<int>(client + 0x31744FC, 5);
                    System.Threading.Thread.Sleep(10);
                    WriteMemory<int>(client + 0x31744FC, 4);
                }

                System.Threading.Thread.Sleep(1);
            }
        }

        static uint GetModuleBaseAddress(string moduleName, IntPtr hwnd)
        {
            ProcessModuleCollection modules = Process.GetProcessById((int)hwnd).Modules;
            foreach (ProcessModule module in modules)
            {
                if (module.ModuleName == moduleName)
                {
                    return (uint)module.BaseAddress;
                }
            }

            return 0;
        }

        static T ReadMemory<T>(uint address) where T : struct
        {
            byte[] buffer = new byte[Marshal.SizeOf(typeof(T))];
            ReadProcessMemory((int)Process.GetCurrentProcess().Handle, address, buffer, buffer.Length, out int bytesRead);
            return ByteArrayToStructure<T>(buffer);
        }

        static void WriteMemory<T>(uint address, T value) where T : struct
        {
            byte[] buffer = StructureToByteArray(value);
            WriteProcessMemory((int)Process.GetCurrentProcess().Handle, address, buffer, buffer.Length, out int bytesWritten);
        }

        static T ByteArrayToStructure<T>(byte[] bytes) where T : struct
        {
            GCHandle handle = GCHandle.Alloc(bytes, GCHandleType.Pinned);
            T result = (T)Marshal.PtrToStructure(handle.AddrOfPinnedObject(), typeof(T));
            handle.Free();
            return result;
        }

        static byte[] StructureToByteArray<T>(T obj) where T : struct
        {
            byte[] bytes = new byte[Marshal.SizeOf(obj)];
            GCHandle handle = GCHandle.Alloc(bytes, GCHandleType.Pinned);
            Marshal.StructureToPtr(obj, handle.AddrOfPinnedObject(), true);
            handle.Free();
            return bytes;
        }

        [DllImport("kernel32.dll")]
        static extern bool ReadProcessMemory(int hProcess, uint lpBaseAddress, [Out] byte[] lpBuffer, int dwSize, out int lpNumberOfBytesRead);

        [DllImport("kernel32.dll")]
        static extern bool WriteProcessMemory(int hProcess, uint lpBaseAddress, byte[] lpBuffer, int dwSize, out int lpNumberOfBytesWritten);
    }
}
